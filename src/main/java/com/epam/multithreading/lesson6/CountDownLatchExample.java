package com.epam.multithreading.lesson6;

import java.util.concurrent.CountDownLatch;

/*
Иногда требуется, чтобы поток исполнения находился в режиме ожидания до тех пор,
пока не наступит одно (или больше) событие.

Для этих целей в парал­лельном API предоставляется класс CountDownLatch, реализующий самоблокировку с обратным отсчетом.
Объект этого класса изначально создается с количеством событий, которые должны произойти до того момента, как будет
снята самоблокировка. Всякий раз, когда происходит событие, значение счетчика уменьшается.

Как только значение счетчика достигнет нуля, самоблокировка будет снята.

В классе CountDownLatch имеется приведенный ниже конструктор, где пара­метр число определяет количество событий,
которые должны произойти до того, как будет снята самоблокировка.

В первой форме ожидание длится до тех пор, пока отсчет, связанный с вызы­вающим объектом типа CountDownLatch,
не достигнет нуля. А во второй форме ожидание длится только в течение определенного периода времени,
определяе­мого параметром ожидание.

Время ожидания указывается в единицах, обозначаемых параметром единица_времени, который принимает объект
перечисления TimeUnit.

Метод await() возвращает ло­гическое значение false, если достигнут предел времени ожидания, или логиче­ское значение
true, если обратный отсчет достигает нуля.

Чтобы известить о событии, следует вызвать метод countDown(). Ниже при­ведена общая форма этого метода.
Всякий раз, когда вызывается метод countDown(), отсчет, связанный с вызывающим объектом, уменьшается на единицу.
*/
public class CountDownLatchExample {

    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(5);

        System.out.println("Starting of thread");

        new ExampleThread(countDownLatch);

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            System.err.println(e.getMessage());
        }

        System.out.println("Finished...");
    }
}

class ExampleThread implements Runnable {
    private CountDownLatch latch;

    public ExampleThread(CountDownLatch latch) {
        this.latch = latch;
        new Thread(this).start();
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(i);
            latch.countDown();
        }
    }
}

/*
* В теле метода mаin() устанавливается самоблокировка в виде объекта cdl типа CountDownLatch с исходным значением
* обратного отсчета, равным 5.

Затем соз­дается экземпляр класса MyThread, который начинает исполнение нового потока. Обратите внимание на то,
что объект cdl передается в качестве параметра конструктору класса MyThread и сохраняется в переменной
экземпляра latch.

Далее в главном потоке исполнения вызывается метод await() для объекта cdl, в результате чего исполнение
главного потока приостанавливается до тех пор. пока обратный отсчет самоблокировки не уменьшится на единицу
пять раз в объекте cdl.

В теле метода run() из класса MyThread организуется цикл, который повторяется пять раз. На каждом шаге этого
цикла вызывается метод countDown() для пе­ременной экземпляра latch, которая ссылается на объект cdl в методе
main(). По завершении пятого шага цикла самоблокировка снимается, позволяя возобновить главный поток
исполнения.

Класс CountDownLatch является эффективным и простым в употреблении средством синхронизации, которое окажется
полезным в тех случаях, когда поток исполнения должен находиться в состоянии ожидания до тех пор, пока не
произойдет одно или несколько событий.*/
